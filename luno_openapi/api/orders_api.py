# coding: utf-8

"""
    Luno API

    The Luno API provides developers with a wealth of financial information provided through the Luno platform.  Through this secure system developers can:  <ul>    <li>Create accounts for trading in cryptocurrencies</li>    <li>Access current and historic cryptocurrency market data</li>    <li>Submit trade orders and view order status</li>    <li>Buy and sell Bitcoin and Ethereum</li>    <li>Send and receive Bitcoin and Ethereum</li>    <li>Generate Bitcoin and Ethereum wallet addresses</li>  </ul>   The Luno API brings the world of Bitcoin and Ethereum to your doorstep. 

    The version of the OpenAPI document: 1.2.5
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

from typing import Any, Dict, List, Optional, Tuple, Union

from pydantic import Field, StrictBool, StrictFloat, StrictInt, StrictStr, validate_call
from typing_extensions import Annotated

from luno_openapi.api_client import ApiClient, RequestSerialized
from luno_openapi.api_response import ApiResponse
from luno_openapi.models.get_fee_info_response import GetFeeInfoResponse
from luno_openapi.models.get_order2_response import GetOrder2Response
from luno_openapi.models.get_order_response import GetOrderResponse
from luno_openapi.models.list_orders2_response import ListOrders2Response
from luno_openapi.models.list_orders_response import ListOrdersResponse
from luno_openapi.models.list_user_trades_response import ListUserTradesResponse
from luno_openapi.models.post_limit_order_response import PostLimitOrderResponse
from luno_openapi.models.post_market_order_response import PostMarketOrderResponse
from luno_openapi.models.stop_order_response import StopOrderResponse
from luno_openapi.rest import RESTResponseType


class OrdersApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client

    @validate_call
    async def get_fee_info(
        self,
        pair: Annotated[
            StrictStr, Field(description="Get fee information about this pair.")
        ],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetFeeInfoResponse:
        """Get fee information

        Returns the fees and 30 day trading volume (as of midnight) for a given currency pair.  For complete details, please see <a href=\"en/countries\">Fees & Features</a>.  Permissions required: <code>Perm_R_Orders</code>

        :param pair: Get fee information about this pair. (required)
        :type pair: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_fee_info_serialize(
            pair=pair,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "GetFeeInfoResponse",
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    async def get_fee_info_with_http_info(
        self,
        pair: Annotated[
            StrictStr, Field(description="Get fee information about this pair.")
        ],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetFeeInfoResponse]:
        """Get fee information

        Returns the fees and 30 day trading volume (as of midnight) for a given currency pair.  For complete details, please see <a href=\"en/countries\">Fees & Features</a>.  Permissions required: <code>Perm_R_Orders</code>

        :param pair: Get fee information about this pair. (required)
        :type pair: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_fee_info_serialize(
            pair=pair,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "GetFeeInfoResponse",
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    async def get_fee_info_without_preload_content(
        self,
        pair: Annotated[
            StrictStr, Field(description="Get fee information about this pair.")
        ],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get fee information

        Returns the fees and 30 day trading volume (as of midnight) for a given currency pair.  For complete details, please see <a href=\"en/countries\">Fees & Features</a>.  Permissions required: <code>Perm_R_Orders</code>

        :param pair: Get fee information about this pair. (required)
        :type pair: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_fee_info_serialize(
            pair=pair,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "GetFeeInfoResponse",
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _get_fee_info_serialize(
        self,
        pair,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if pair is not None:

            _query_params.append(("pair", pair))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if "Accept" not in _header_params:
            _header_params["Accept"] = self.api_client.select_header_accept(
                ["application/json"]
            )

        # authentication setting
        _auth_settings: List[str] = []

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/api/1/fee_info",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    async def get_order(
        self,
        id: Annotated[StrictStr, Field(description="Order reference")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetOrderResponse:
        """Get order

        Get an Order's details by its ID.  Permissions required: <code>Perm_R_Orders</code>

        :param id: Order reference (required)
        :type id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_order_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "GetOrderResponse",
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    async def get_order_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="Order reference")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetOrderResponse]:
        """Get order

        Get an Order's details by its ID.  Permissions required: <code>Perm_R_Orders</code>

        :param id: Order reference (required)
        :type id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_order_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "GetOrderResponse",
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    async def get_order_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="Order reference")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get order

        Get an Order's details by its ID.  Permissions required: <code>Perm_R_Orders</code>

        :param id: Order reference (required)
        :type id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_order_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "GetOrderResponse",
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _get_order_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params["id"] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if "Accept" not in _header_params:
            _header_params["Accept"] = self.api_client.select_header_accept(
                ["application/json"]
            )

        # authentication setting
        _auth_settings: List[str] = []

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/api/1/orders/{id}",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    async def get_order_v2(
        self,
        id: Annotated[StrictStr, Field(description="Order reference")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetOrder2Response:
        """Get Order v2

        Get the details for an order.  Permissions required: <code>Perm_R_Orders</code>

        :param id: Order reference (required)
        :type id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_order_v2_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "GetOrder2Response",
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    async def get_order_v2_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="Order reference")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetOrder2Response]:
        """Get Order v2

        Get the details for an order.  Permissions required: <code>Perm_R_Orders</code>

        :param id: Order reference (required)
        :type id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_order_v2_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "GetOrder2Response",
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    async def get_order_v2_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="Order reference")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get Order v2

        Get the details for an order.  Permissions required: <code>Perm_R_Orders</code>

        :param id: Order reference (required)
        :type id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_order_v2_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "GetOrder2Response",
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _get_order_v2_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params["id"] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if "Accept" not in _header_params:
            _header_params["Accept"] = self.api_client.select_header_accept(
                ["application/json"]
            )

        # authentication setting
        _auth_settings: List[str] = []

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/api/exchange/2/orders/{id}",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    async def get_order_v3(
        self,
        id: Annotated[Optional[StrictStr], Field(description="Order reference")] = None,
        client_order_id: Annotated[
            Optional[StrictStr],
            Field(
                description="Client Order ID has the value that was passed in when the Order was posted."
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetOrder2Response:
        """Get Order v3

        Get the details for an order by order reference or client order ID. Exactly one of the two parameters must be provided, otherwise an error is returned. Permissions required: <code>Perm_R_Orders</code>

        :param id: Order reference
        :type id: str
        :param client_order_id: Client Order ID has the value that was passed in when the Order was posted.
        :type client_order_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_order_v3_serialize(
            id=id,
            client_order_id=client_order_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "GetOrder2Response",
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    async def get_order_v3_with_http_info(
        self,
        id: Annotated[Optional[StrictStr], Field(description="Order reference")] = None,
        client_order_id: Annotated[
            Optional[StrictStr],
            Field(
                description="Client Order ID has the value that was passed in when the Order was posted."
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetOrder2Response]:
        """Get Order v3

        Get the details for an order by order reference or client order ID. Exactly one of the two parameters must be provided, otherwise an error is returned. Permissions required: <code>Perm_R_Orders</code>

        :param id: Order reference
        :type id: str
        :param client_order_id: Client Order ID has the value that was passed in when the Order was posted.
        :type client_order_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_order_v3_serialize(
            id=id,
            client_order_id=client_order_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "GetOrder2Response",
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    async def get_order_v3_without_preload_content(
        self,
        id: Annotated[Optional[StrictStr], Field(description="Order reference")] = None,
        client_order_id: Annotated[
            Optional[StrictStr],
            Field(
                description="Client Order ID has the value that was passed in when the Order was posted."
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get Order v3

        Get the details for an order by order reference or client order ID. Exactly one of the two parameters must be provided, otherwise an error is returned. Permissions required: <code>Perm_R_Orders</code>

        :param id: Order reference
        :type id: str
        :param client_order_id: Client Order ID has the value that was passed in when the Order was posted.
        :type client_order_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_order_v3_serialize(
            id=id,
            client_order_id=client_order_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "GetOrder2Response",
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _get_order_v3_serialize(
        self,
        id,
        client_order_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if id is not None:

            _query_params.append(("id", id))

        if client_order_id is not None:

            _query_params.append(("client_order_id", client_order_id))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if "Accept" not in _header_params:
            _header_params["Accept"] = self.api_client.select_header_accept(
                ["application/json"]
            )

        # authentication setting
        _auth_settings: List[str] = []

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/api/exchange/3/order",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    async def list_orders(
        self,
        state: Annotated[
            Optional[StrictStr],
            Field(description="Filter to only orders of this state"),
        ] = None,
        pair: Annotated[
            Optional[StrictStr],
            Field(description="Filter to only orders of this currency pair"),
        ] = None,
        created_before: Annotated[
            Optional[StrictInt],
            Field(
                description="Filter to orders created before this timestamp (Unix milliseconds)"
            ),
        ] = None,
        limit: Annotated[
            Optional[Annotated[int, Field(le=1000, strict=True, ge=1)]],
            Field(description="Limit to this many orders"),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ListOrdersResponse:
        """List orders

        Returns a list of the most recently placed Orders. Users can specify an optional <code>state=PENDING</code> parameter to restrict the results to only open Orders. Users can also specify the market by using the optional currency pair parameter.  Permissions required: <code>Perm_R_Orders</code>

        :param state: Filter to only orders of this state
        :type state: str
        :param pair: Filter to only orders of this currency pair
        :type pair: str
        :param created_before: Filter to orders created before this timestamp (Unix milliseconds)
        :type created_before: int
        :param limit: Limit to this many orders
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._list_orders_serialize(
            state=state,
            pair=pair,
            created_before=created_before,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "ListOrdersResponse",
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    async def list_orders_with_http_info(
        self,
        state: Annotated[
            Optional[StrictStr],
            Field(description="Filter to only orders of this state"),
        ] = None,
        pair: Annotated[
            Optional[StrictStr],
            Field(description="Filter to only orders of this currency pair"),
        ] = None,
        created_before: Annotated[
            Optional[StrictInt],
            Field(
                description="Filter to orders created before this timestamp (Unix milliseconds)"
            ),
        ] = None,
        limit: Annotated[
            Optional[Annotated[int, Field(le=1000, strict=True, ge=1)]],
            Field(description="Limit to this many orders"),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ListOrdersResponse]:
        """List orders

        Returns a list of the most recently placed Orders. Users can specify an optional <code>state=PENDING</code> parameter to restrict the results to only open Orders. Users can also specify the market by using the optional currency pair parameter.  Permissions required: <code>Perm_R_Orders</code>

        :param state: Filter to only orders of this state
        :type state: str
        :param pair: Filter to only orders of this currency pair
        :type pair: str
        :param created_before: Filter to orders created before this timestamp (Unix milliseconds)
        :type created_before: int
        :param limit: Limit to this many orders
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._list_orders_serialize(
            state=state,
            pair=pair,
            created_before=created_before,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "ListOrdersResponse",
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    async def list_orders_without_preload_content(
        self,
        state: Annotated[
            Optional[StrictStr],
            Field(description="Filter to only orders of this state"),
        ] = None,
        pair: Annotated[
            Optional[StrictStr],
            Field(description="Filter to only orders of this currency pair"),
        ] = None,
        created_before: Annotated[
            Optional[StrictInt],
            Field(
                description="Filter to orders created before this timestamp (Unix milliseconds)"
            ),
        ] = None,
        limit: Annotated[
            Optional[Annotated[int, Field(le=1000, strict=True, ge=1)]],
            Field(description="Limit to this many orders"),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """List orders

        Returns a list of the most recently placed Orders. Users can specify an optional <code>state=PENDING</code> parameter to restrict the results to only open Orders. Users can also specify the market by using the optional currency pair parameter.  Permissions required: <code>Perm_R_Orders</code>

        :param state: Filter to only orders of this state
        :type state: str
        :param pair: Filter to only orders of this currency pair
        :type pair: str
        :param created_before: Filter to orders created before this timestamp (Unix milliseconds)
        :type created_before: int
        :param limit: Limit to this many orders
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._list_orders_serialize(
            state=state,
            pair=pair,
            created_before=created_before,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "ListOrdersResponse",
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _list_orders_serialize(
        self,
        state,
        pair,
        created_before,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if state is not None:

            _query_params.append(("state", state))

        if pair is not None:

            _query_params.append(("pair", pair))

        if created_before is not None:

            _query_params.append(("created_before", created_before))

        if limit is not None:

            _query_params.append(("limit", limit))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if "Accept" not in _header_params:
            _header_params["Accept"] = self.api_client.select_header_accept(
                ["application/json"]
            )

        # authentication setting
        _auth_settings: List[str] = []

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/api/1/listorders",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    async def list_orders_v2(
        self,
        pair: Annotated[
            Optional[StrictStr],
            Field(description="Filter to only orders of this currency pair."),
        ] = None,
        closed: Annotated[
            Optional[StrictBool],
            Field(
                description="If true, will return closed orders instead of open orders."
            ),
        ] = None,
        created_before: Annotated[
            Optional[StrictInt],
            Field(
                description="Filter to orders created before this timestamp (Unix milliseconds)"
            ),
        ] = None,
        limit: Annotated[
            Optional[Annotated[int, Field(le=1000, strict=True, ge=1)]],
            Field(description="Limit to this many orders"),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ListOrders2Response:
        """List Orders v2

        Returns a list of the most recently placed orders ordered from newest to oldest. This endpoint will list up to 100 most recent open orders by default.  <b>Please note:</b> This data is archived 100 days after an exchange order is completed.  Permissions required: <Code>Perm_R_Orders</Code>

        :param pair: Filter to only orders of this currency pair.
        :type pair: str
        :param closed: If true, will return closed orders instead of open orders.
        :type closed: bool
        :param created_before: Filter to orders created before this timestamp (Unix milliseconds)
        :type created_before: int
        :param limit: Limit to this many orders
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._list_orders_v2_serialize(
            pair=pair,
            closed=closed,
            created_before=created_before,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "ListOrders2Response",
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    async def list_orders_v2_with_http_info(
        self,
        pair: Annotated[
            Optional[StrictStr],
            Field(description="Filter to only orders of this currency pair."),
        ] = None,
        closed: Annotated[
            Optional[StrictBool],
            Field(
                description="If true, will return closed orders instead of open orders."
            ),
        ] = None,
        created_before: Annotated[
            Optional[StrictInt],
            Field(
                description="Filter to orders created before this timestamp (Unix milliseconds)"
            ),
        ] = None,
        limit: Annotated[
            Optional[Annotated[int, Field(le=1000, strict=True, ge=1)]],
            Field(description="Limit to this many orders"),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ListOrders2Response]:
        """List Orders v2

        Returns a list of the most recently placed orders ordered from newest to oldest. This endpoint will list up to 100 most recent open orders by default.  <b>Please note:</b> This data is archived 100 days after an exchange order is completed.  Permissions required: <Code>Perm_R_Orders</Code>

        :param pair: Filter to only orders of this currency pair.
        :type pair: str
        :param closed: If true, will return closed orders instead of open orders.
        :type closed: bool
        :param created_before: Filter to orders created before this timestamp (Unix milliseconds)
        :type created_before: int
        :param limit: Limit to this many orders
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._list_orders_v2_serialize(
            pair=pair,
            closed=closed,
            created_before=created_before,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "ListOrders2Response",
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    async def list_orders_v2_without_preload_content(
        self,
        pair: Annotated[
            Optional[StrictStr],
            Field(description="Filter to only orders of this currency pair."),
        ] = None,
        closed: Annotated[
            Optional[StrictBool],
            Field(
                description="If true, will return closed orders instead of open orders."
            ),
        ] = None,
        created_before: Annotated[
            Optional[StrictInt],
            Field(
                description="Filter to orders created before this timestamp (Unix milliseconds)"
            ),
        ] = None,
        limit: Annotated[
            Optional[Annotated[int, Field(le=1000, strict=True, ge=1)]],
            Field(description="Limit to this many orders"),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """List Orders v2

        Returns a list of the most recently placed orders ordered from newest to oldest. This endpoint will list up to 100 most recent open orders by default.  <b>Please note:</b> This data is archived 100 days after an exchange order is completed.  Permissions required: <Code>Perm_R_Orders</Code>

        :param pair: Filter to only orders of this currency pair.
        :type pair: str
        :param closed: If true, will return closed orders instead of open orders.
        :type closed: bool
        :param created_before: Filter to orders created before this timestamp (Unix milliseconds)
        :type created_before: int
        :param limit: Limit to this many orders
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._list_orders_v2_serialize(
            pair=pair,
            closed=closed,
            created_before=created_before,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "ListOrders2Response",
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _list_orders_v2_serialize(
        self,
        pair,
        closed,
        created_before,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if pair is not None:

            _query_params.append(("pair", pair))

        if closed is not None:

            _query_params.append(("closed", closed))

        if created_before is not None:

            _query_params.append(("created_before", created_before))

        if limit is not None:

            _query_params.append(("limit", limit))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if "Accept" not in _header_params:
            _header_params["Accept"] = self.api_client.select_header_accept(
                ["application/json"]
            )

        # authentication setting
        _auth_settings: List[str] = []

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/api/exchange/2/listorders",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    async def list_user_trades(
        self,
        pair: Annotated[
            StrictStr, Field(description="Filter to trades of this currency pair.")
        ],
        since: Annotated[
            Optional[StrictInt],
            Field(
                description="Filter to trades on or after this timestamp (Unix milliseconds)."
            ),
        ] = None,
        before: Annotated[
            Optional[StrictInt],
            Field(
                description="Filter to trades before this timestamp (Unix milliseconds)."
            ),
        ] = None,
        after_seq: Annotated[
            Optional[StrictInt],
            Field(
                description="Filter to trades from (including) this sequence number. Default behaviour is not to include this filter."
            ),
        ] = None,
        before_seq: Annotated[
            Optional[StrictInt],
            Field(
                description="Filter to trades before (excluding) this sequence number. Default behaviour is not to include this filter."
            ),
        ] = None,
        sort_desc: Annotated[
            Optional[StrictBool],
            Field(
                description="If set to true, sorts trades in descending order, otherwise ascending order will be assumed."
            ),
        ] = None,
        limit: Annotated[
            Optional[Annotated[int, Field(le=1000, strict=True, ge=1)]],
            Field(description="Limit to this number of trades (default 100)."),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ListUserTradesResponse:
        """List trades

        Returns a list of the recent Trades for a given currency pair for this user, sorted by oldest first. If <code>before</code> is specified, then Trades are returned sorted by most-recent first.  <code>type</code> in the response indicates the type of Order that was placed to participate in the trade. Possible types: <code>BID</code>, <code>ASK</code>.  If <code>is_buy</code> in the response is true, then the Order which completed the trade (market taker) was a Bid Order.  Results of this query may lag behind the latest data.  Permissions required: <code>Perm_R_Orders</code>

        :param pair: Filter to trades of this currency pair. (required)
        :type pair: str
        :param since: Filter to trades on or after this timestamp (Unix milliseconds).
        :type since: int
        :param before: Filter to trades before this timestamp (Unix milliseconds).
        :type before: int
        :param after_seq: Filter to trades from (including) this sequence number. Default behaviour is not to include this filter.
        :type after_seq: int
        :param before_seq: Filter to trades before (excluding) this sequence number. Default behaviour is not to include this filter.
        :type before_seq: int
        :param sort_desc: If set to true, sorts trades in descending order, otherwise ascending order will be assumed.
        :type sort_desc: bool
        :param limit: Limit to this number of trades (default 100).
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._list_user_trades_serialize(
            pair=pair,
            since=since,
            before=before,
            after_seq=after_seq,
            before_seq=before_seq,
            sort_desc=sort_desc,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "ListUserTradesResponse",
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    async def list_user_trades_with_http_info(
        self,
        pair: Annotated[
            StrictStr, Field(description="Filter to trades of this currency pair.")
        ],
        since: Annotated[
            Optional[StrictInt],
            Field(
                description="Filter to trades on or after this timestamp (Unix milliseconds)."
            ),
        ] = None,
        before: Annotated[
            Optional[StrictInt],
            Field(
                description="Filter to trades before this timestamp (Unix milliseconds)."
            ),
        ] = None,
        after_seq: Annotated[
            Optional[StrictInt],
            Field(
                description="Filter to trades from (including) this sequence number. Default behaviour is not to include this filter."
            ),
        ] = None,
        before_seq: Annotated[
            Optional[StrictInt],
            Field(
                description="Filter to trades before (excluding) this sequence number. Default behaviour is not to include this filter."
            ),
        ] = None,
        sort_desc: Annotated[
            Optional[StrictBool],
            Field(
                description="If set to true, sorts trades in descending order, otherwise ascending order will be assumed."
            ),
        ] = None,
        limit: Annotated[
            Optional[Annotated[int, Field(le=1000, strict=True, ge=1)]],
            Field(description="Limit to this number of trades (default 100)."),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ListUserTradesResponse]:
        """List trades

        Returns a list of the recent Trades for a given currency pair for this user, sorted by oldest first. If <code>before</code> is specified, then Trades are returned sorted by most-recent first.  <code>type</code> in the response indicates the type of Order that was placed to participate in the trade. Possible types: <code>BID</code>, <code>ASK</code>.  If <code>is_buy</code> in the response is true, then the Order which completed the trade (market taker) was a Bid Order.  Results of this query may lag behind the latest data.  Permissions required: <code>Perm_R_Orders</code>

        :param pair: Filter to trades of this currency pair. (required)
        :type pair: str
        :param since: Filter to trades on or after this timestamp (Unix milliseconds).
        :type since: int
        :param before: Filter to trades before this timestamp (Unix milliseconds).
        :type before: int
        :param after_seq: Filter to trades from (including) this sequence number. Default behaviour is not to include this filter.
        :type after_seq: int
        :param before_seq: Filter to trades before (excluding) this sequence number. Default behaviour is not to include this filter.
        :type before_seq: int
        :param sort_desc: If set to true, sorts trades in descending order, otherwise ascending order will be assumed.
        :type sort_desc: bool
        :param limit: Limit to this number of trades (default 100).
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._list_user_trades_serialize(
            pair=pair,
            since=since,
            before=before,
            after_seq=after_seq,
            before_seq=before_seq,
            sort_desc=sort_desc,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "ListUserTradesResponse",
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    async def list_user_trades_without_preload_content(
        self,
        pair: Annotated[
            StrictStr, Field(description="Filter to trades of this currency pair.")
        ],
        since: Annotated[
            Optional[StrictInt],
            Field(
                description="Filter to trades on or after this timestamp (Unix milliseconds)."
            ),
        ] = None,
        before: Annotated[
            Optional[StrictInt],
            Field(
                description="Filter to trades before this timestamp (Unix milliseconds)."
            ),
        ] = None,
        after_seq: Annotated[
            Optional[StrictInt],
            Field(
                description="Filter to trades from (including) this sequence number. Default behaviour is not to include this filter."
            ),
        ] = None,
        before_seq: Annotated[
            Optional[StrictInt],
            Field(
                description="Filter to trades before (excluding) this sequence number. Default behaviour is not to include this filter."
            ),
        ] = None,
        sort_desc: Annotated[
            Optional[StrictBool],
            Field(
                description="If set to true, sorts trades in descending order, otherwise ascending order will be assumed."
            ),
        ] = None,
        limit: Annotated[
            Optional[Annotated[int, Field(le=1000, strict=True, ge=1)]],
            Field(description="Limit to this number of trades (default 100)."),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """List trades

        Returns a list of the recent Trades for a given currency pair for this user, sorted by oldest first. If <code>before</code> is specified, then Trades are returned sorted by most-recent first.  <code>type</code> in the response indicates the type of Order that was placed to participate in the trade. Possible types: <code>BID</code>, <code>ASK</code>.  If <code>is_buy</code> in the response is true, then the Order which completed the trade (market taker) was a Bid Order.  Results of this query may lag behind the latest data.  Permissions required: <code>Perm_R_Orders</code>

        :param pair: Filter to trades of this currency pair. (required)
        :type pair: str
        :param since: Filter to trades on or after this timestamp (Unix milliseconds).
        :type since: int
        :param before: Filter to trades before this timestamp (Unix milliseconds).
        :type before: int
        :param after_seq: Filter to trades from (including) this sequence number. Default behaviour is not to include this filter.
        :type after_seq: int
        :param before_seq: Filter to trades before (excluding) this sequence number. Default behaviour is not to include this filter.
        :type before_seq: int
        :param sort_desc: If set to true, sorts trades in descending order, otherwise ascending order will be assumed.
        :type sort_desc: bool
        :param limit: Limit to this number of trades (default 100).
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._list_user_trades_serialize(
            pair=pair,
            since=since,
            before=before,
            after_seq=after_seq,
            before_seq=before_seq,
            sort_desc=sort_desc,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "ListUserTradesResponse",
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _list_user_trades_serialize(
        self,
        pair,
        since,
        before,
        after_seq,
        before_seq,
        sort_desc,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if pair is not None:

            _query_params.append(("pair", pair))

        if since is not None:

            _query_params.append(("since", since))

        if before is not None:

            _query_params.append(("before", before))

        if after_seq is not None:

            _query_params.append(("after_seq", after_seq))

        if before_seq is not None:

            _query_params.append(("before_seq", before_seq))

        if sort_desc is not None:

            _query_params.append(("sort_desc", sort_desc))

        if limit is not None:

            _query_params.append(("limit", limit))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if "Accept" not in _header_params:
            _header_params["Accept"] = self.api_client.select_header_accept(
                ["application/json"]
            )

        # authentication setting
        _auth_settings: List[str] = []

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/api/1/listtrades",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    async def post_limit_order(
        self,
        pair: Annotated[StrictStr, Field(description="The currency pair to trade.")],
        type: Annotated[
            StrictStr,
            Field(
                description="<code>BID</code> for a bid (buy) limit order<br> <code>ASK</code> for an ask (sell) limit order"
            ),
        ],
        volume: Annotated[
            StrictStr,
            Field(
                description="Amount of cryptocurrency to buy or sell as a decimal string in units of the currency."
            ),
        ],
        price: Annotated[
            StrictStr,
            Field(description="Limit price as a decimal string in units of ZAR/BTC."),
        ],
        time_in_force: Annotated[
            Optional[StrictStr],
            Field(
                description="<code>GTC</code> Good 'Til Cancelled. The order remains open until it is filled or cancelled by the user.</br> <code>IOC</code> Immediate Or Cancel. The part of the order that cannot be filled immediately will be cancelled. Cannot be post-only.</br> <code>FOK</code> Fill Or Kill. If the order cannot be filled immediately and completely it will be cancelled before any trade. Cannot be post-only."
            ),
        ] = None,
        post_only: Annotated[
            Optional[StrictBool],
            Field(
                description="Post-only Orders will be cancelled if they would otherwise have traded immediately. For example, if there's a bid at ZAR 100,000 and you place a post-only ask at ZAR 100,000, your order will be cancelled instead of trading. If the best bid is ZAR 100,000 and you place a post-only ask at ZAR 101,000, your order won't trade but will go into the order book."
            ),
        ] = None,
        stop_price: Annotated[
            Optional[StrictStr],
            Field(
                description="Trigger trade price to activate this order as a decimal string. If this is set then this is treated as a Stop Limit Order and `stop_direction` is expected to be set too."
            ),
        ] = None,
        stop_direction: Annotated[
            Optional[StrictStr],
            Field(
                description="Side of the trigger price to activate the order. This should be set if `stop_price` is also set.  `RELATIVE_LAST_TRADE` will automatically infer the direction based on the last trade price and the stop price. If last trade price is less than stop price then stop direction is ABOVE otherwise is BELOW."
            ),
        ] = None,
        base_account_id: Annotated[
            Optional[StrictInt],
            Field(description="The base currency Account to use in the trade."),
        ] = None,
        counter_account_id: Annotated[
            Optional[StrictInt],
            Field(description="The counter currency Account to use in the trade."),
        ] = None,
        timestamp: Annotated[
            Optional[StrictInt],
            Field(
                description="Unix timestamp in milliseconds of when the request was created and sent."
            ),
        ] = None,
        ttl: Annotated[
            Optional[Annotated[int, Field(le=10000, strict=True, ge=1)]],
            Field(
                description="Specifies the number of milliseconds after timestamp the request is valid for. If `timestamp` is not specified, `ttl` will not be used."
            ),
        ] = None,
        client_order_id: Annotated[
            Optional[StrictStr],
            Field(
                description="Client order ID. May only contain alphanumeric (0-9, a-z, or A-Z) and special characters (_ ; , . -). Maximum length: 255. It will be available in read endpoints, so you can use it to reconcile Luno with your internal system. Values must be unique across all your successful order creation endpoint calls; trying to create an order with the same `client_order_id` as one of your past orders will result in a HTTP 409 Conflict response."
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> PostLimitOrderResponse:
        """Post Limit Order

        <b>Warning!</b> Orders cannot be reversed once they have executed. Please ensure your program has been thoroughly tested before submitting Orders.  If no <code>base_account_id</code> or <code>counter_account_id</code> are specified, your default base currency or counter currency account will be used. You can find your Account IDs by calling the <a href=\"#operation/getBalances\">Balances</a> API.  Permissions required: <code>Perm_W_Orders</code>

        :param pair: The currency pair to trade. (required)
        :type pair: str
        :param type: <code>BID</code> for a bid (buy) limit order<br> <code>ASK</code> for an ask (sell) limit order (required)
        :type type: str
        :param volume: Amount of cryptocurrency to buy or sell as a decimal string in units of the currency. (required)
        :type volume: str
        :param price: Limit price as a decimal string in units of ZAR/BTC. (required)
        :type price: str
        :param time_in_force: <code>GTC</code> Good 'Til Cancelled. The order remains open until it is filled or cancelled by the user.</br> <code>IOC</code> Immediate Or Cancel. The part of the order that cannot be filled immediately will be cancelled. Cannot be post-only.</br> <code>FOK</code> Fill Or Kill. If the order cannot be filled immediately and completely it will be cancelled before any trade. Cannot be post-only.
        :type time_in_force: str
        :param post_only: Post-only Orders will be cancelled if they would otherwise have traded immediately. For example, if there's a bid at ZAR 100,000 and you place a post-only ask at ZAR 100,000, your order will be cancelled instead of trading. If the best bid is ZAR 100,000 and you place a post-only ask at ZAR 101,000, your order won't trade but will go into the order book.
        :type post_only: bool
        :param stop_price: Trigger trade price to activate this order as a decimal string. If this is set then this is treated as a Stop Limit Order and `stop_direction` is expected to be set too.
        :type stop_price: str
        :param stop_direction: Side of the trigger price to activate the order. This should be set if `stop_price` is also set.  `RELATIVE_LAST_TRADE` will automatically infer the direction based on the last trade price and the stop price. If last trade price is less than stop price then stop direction is ABOVE otherwise is BELOW.
        :type stop_direction: str
        :param base_account_id: The base currency Account to use in the trade.
        :type base_account_id: int
        :param counter_account_id: The counter currency Account to use in the trade.
        :type counter_account_id: int
        :param timestamp: Unix timestamp in milliseconds of when the request was created and sent.
        :type timestamp: int
        :param ttl: Specifies the number of milliseconds after timestamp the request is valid for. If `timestamp` is not specified, `ttl` will not be used.
        :type ttl: int
        :param client_order_id: Client order ID. May only contain alphanumeric (0-9, a-z, or A-Z) and special characters (_ ; , . -). Maximum length: 255. It will be available in read endpoints, so you can use it to reconcile Luno with your internal system. Values must be unique across all your successful order creation endpoint calls; trying to create an order with the same `client_order_id` as one of your past orders will result in a HTTP 409 Conflict response.
        :type client_order_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._post_limit_order_serialize(
            pair=pair,
            type=type,
            volume=volume,
            price=price,
            time_in_force=time_in_force,
            post_only=post_only,
            stop_price=stop_price,
            stop_direction=stop_direction,
            base_account_id=base_account_id,
            counter_account_id=counter_account_id,
            timestamp=timestamp,
            ttl=ttl,
            client_order_id=client_order_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "PostLimitOrderResponse",
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    async def post_limit_order_with_http_info(
        self,
        pair: Annotated[StrictStr, Field(description="The currency pair to trade.")],
        type: Annotated[
            StrictStr,
            Field(
                description="<code>BID</code> for a bid (buy) limit order<br> <code>ASK</code> for an ask (sell) limit order"
            ),
        ],
        volume: Annotated[
            StrictStr,
            Field(
                description="Amount of cryptocurrency to buy or sell as a decimal string in units of the currency."
            ),
        ],
        price: Annotated[
            StrictStr,
            Field(description="Limit price as a decimal string in units of ZAR/BTC."),
        ],
        time_in_force: Annotated[
            Optional[StrictStr],
            Field(
                description="<code>GTC</code> Good 'Til Cancelled. The order remains open until it is filled or cancelled by the user.</br> <code>IOC</code> Immediate Or Cancel. The part of the order that cannot be filled immediately will be cancelled. Cannot be post-only.</br> <code>FOK</code> Fill Or Kill. If the order cannot be filled immediately and completely it will be cancelled before any trade. Cannot be post-only."
            ),
        ] = None,
        post_only: Annotated[
            Optional[StrictBool],
            Field(
                description="Post-only Orders will be cancelled if they would otherwise have traded immediately. For example, if there's a bid at ZAR 100,000 and you place a post-only ask at ZAR 100,000, your order will be cancelled instead of trading. If the best bid is ZAR 100,000 and you place a post-only ask at ZAR 101,000, your order won't trade but will go into the order book."
            ),
        ] = None,
        stop_price: Annotated[
            Optional[StrictStr],
            Field(
                description="Trigger trade price to activate this order as a decimal string. If this is set then this is treated as a Stop Limit Order and `stop_direction` is expected to be set too."
            ),
        ] = None,
        stop_direction: Annotated[
            Optional[StrictStr],
            Field(
                description="Side of the trigger price to activate the order. This should be set if `stop_price` is also set.  `RELATIVE_LAST_TRADE` will automatically infer the direction based on the last trade price and the stop price. If last trade price is less than stop price then stop direction is ABOVE otherwise is BELOW."
            ),
        ] = None,
        base_account_id: Annotated[
            Optional[StrictInt],
            Field(description="The base currency Account to use in the trade."),
        ] = None,
        counter_account_id: Annotated[
            Optional[StrictInt],
            Field(description="The counter currency Account to use in the trade."),
        ] = None,
        timestamp: Annotated[
            Optional[StrictInt],
            Field(
                description="Unix timestamp in milliseconds of when the request was created and sent."
            ),
        ] = None,
        ttl: Annotated[
            Optional[Annotated[int, Field(le=10000, strict=True, ge=1)]],
            Field(
                description="Specifies the number of milliseconds after timestamp the request is valid for. If `timestamp` is not specified, `ttl` will not be used."
            ),
        ] = None,
        client_order_id: Annotated[
            Optional[StrictStr],
            Field(
                description="Client order ID. May only contain alphanumeric (0-9, a-z, or A-Z) and special characters (_ ; , . -). Maximum length: 255. It will be available in read endpoints, so you can use it to reconcile Luno with your internal system. Values must be unique across all your successful order creation endpoint calls; trying to create an order with the same `client_order_id` as one of your past orders will result in a HTTP 409 Conflict response."
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[PostLimitOrderResponse]:
        """Post Limit Order

        <b>Warning!</b> Orders cannot be reversed once they have executed. Please ensure your program has been thoroughly tested before submitting Orders.  If no <code>base_account_id</code> or <code>counter_account_id</code> are specified, your default base currency or counter currency account will be used. You can find your Account IDs by calling the <a href=\"#operation/getBalances\">Balances</a> API.  Permissions required: <code>Perm_W_Orders</code>

        :param pair: The currency pair to trade. (required)
        :type pair: str
        :param type: <code>BID</code> for a bid (buy) limit order<br> <code>ASK</code> for an ask (sell) limit order (required)
        :type type: str
        :param volume: Amount of cryptocurrency to buy or sell as a decimal string in units of the currency. (required)
        :type volume: str
        :param price: Limit price as a decimal string in units of ZAR/BTC. (required)
        :type price: str
        :param time_in_force: <code>GTC</code> Good 'Til Cancelled. The order remains open until it is filled or cancelled by the user.</br> <code>IOC</code> Immediate Or Cancel. The part of the order that cannot be filled immediately will be cancelled. Cannot be post-only.</br> <code>FOK</code> Fill Or Kill. If the order cannot be filled immediately and completely it will be cancelled before any trade. Cannot be post-only.
        :type time_in_force: str
        :param post_only: Post-only Orders will be cancelled if they would otherwise have traded immediately. For example, if there's a bid at ZAR 100,000 and you place a post-only ask at ZAR 100,000, your order will be cancelled instead of trading. If the best bid is ZAR 100,000 and you place a post-only ask at ZAR 101,000, your order won't trade but will go into the order book.
        :type post_only: bool
        :param stop_price: Trigger trade price to activate this order as a decimal string. If this is set then this is treated as a Stop Limit Order and `stop_direction` is expected to be set too.
        :type stop_price: str
        :param stop_direction: Side of the trigger price to activate the order. This should be set if `stop_price` is also set.  `RELATIVE_LAST_TRADE` will automatically infer the direction based on the last trade price and the stop price. If last trade price is less than stop price then stop direction is ABOVE otherwise is BELOW.
        :type stop_direction: str
        :param base_account_id: The base currency Account to use in the trade.
        :type base_account_id: int
        :param counter_account_id: The counter currency Account to use in the trade.
        :type counter_account_id: int
        :param timestamp: Unix timestamp in milliseconds of when the request was created and sent.
        :type timestamp: int
        :param ttl: Specifies the number of milliseconds after timestamp the request is valid for. If `timestamp` is not specified, `ttl` will not be used.
        :type ttl: int
        :param client_order_id: Client order ID. May only contain alphanumeric (0-9, a-z, or A-Z) and special characters (_ ; , . -). Maximum length: 255. It will be available in read endpoints, so you can use it to reconcile Luno with your internal system. Values must be unique across all your successful order creation endpoint calls; trying to create an order with the same `client_order_id` as one of your past orders will result in a HTTP 409 Conflict response.
        :type client_order_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._post_limit_order_serialize(
            pair=pair,
            type=type,
            volume=volume,
            price=price,
            time_in_force=time_in_force,
            post_only=post_only,
            stop_price=stop_price,
            stop_direction=stop_direction,
            base_account_id=base_account_id,
            counter_account_id=counter_account_id,
            timestamp=timestamp,
            ttl=ttl,
            client_order_id=client_order_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "PostLimitOrderResponse",
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    async def post_limit_order_without_preload_content(
        self,
        pair: Annotated[StrictStr, Field(description="The currency pair to trade.")],
        type: Annotated[
            StrictStr,
            Field(
                description="<code>BID</code> for a bid (buy) limit order<br> <code>ASK</code> for an ask (sell) limit order"
            ),
        ],
        volume: Annotated[
            StrictStr,
            Field(
                description="Amount of cryptocurrency to buy or sell as a decimal string in units of the currency."
            ),
        ],
        price: Annotated[
            StrictStr,
            Field(description="Limit price as a decimal string in units of ZAR/BTC."),
        ],
        time_in_force: Annotated[
            Optional[StrictStr],
            Field(
                description="<code>GTC</code> Good 'Til Cancelled. The order remains open until it is filled or cancelled by the user.</br> <code>IOC</code> Immediate Or Cancel. The part of the order that cannot be filled immediately will be cancelled. Cannot be post-only.</br> <code>FOK</code> Fill Or Kill. If the order cannot be filled immediately and completely it will be cancelled before any trade. Cannot be post-only."
            ),
        ] = None,
        post_only: Annotated[
            Optional[StrictBool],
            Field(
                description="Post-only Orders will be cancelled if they would otherwise have traded immediately. For example, if there's a bid at ZAR 100,000 and you place a post-only ask at ZAR 100,000, your order will be cancelled instead of trading. If the best bid is ZAR 100,000 and you place a post-only ask at ZAR 101,000, your order won't trade but will go into the order book."
            ),
        ] = None,
        stop_price: Annotated[
            Optional[StrictStr],
            Field(
                description="Trigger trade price to activate this order as a decimal string. If this is set then this is treated as a Stop Limit Order and `stop_direction` is expected to be set too."
            ),
        ] = None,
        stop_direction: Annotated[
            Optional[StrictStr],
            Field(
                description="Side of the trigger price to activate the order. This should be set if `stop_price` is also set.  `RELATIVE_LAST_TRADE` will automatically infer the direction based on the last trade price and the stop price. If last trade price is less than stop price then stop direction is ABOVE otherwise is BELOW."
            ),
        ] = None,
        base_account_id: Annotated[
            Optional[StrictInt],
            Field(description="The base currency Account to use in the trade."),
        ] = None,
        counter_account_id: Annotated[
            Optional[StrictInt],
            Field(description="The counter currency Account to use in the trade."),
        ] = None,
        timestamp: Annotated[
            Optional[StrictInt],
            Field(
                description="Unix timestamp in milliseconds of when the request was created and sent."
            ),
        ] = None,
        ttl: Annotated[
            Optional[Annotated[int, Field(le=10000, strict=True, ge=1)]],
            Field(
                description="Specifies the number of milliseconds after timestamp the request is valid for. If `timestamp` is not specified, `ttl` will not be used."
            ),
        ] = None,
        client_order_id: Annotated[
            Optional[StrictStr],
            Field(
                description="Client order ID. May only contain alphanumeric (0-9, a-z, or A-Z) and special characters (_ ; , . -). Maximum length: 255. It will be available in read endpoints, so you can use it to reconcile Luno with your internal system. Values must be unique across all your successful order creation endpoint calls; trying to create an order with the same `client_order_id` as one of your past orders will result in a HTTP 409 Conflict response."
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Post Limit Order

        <b>Warning!</b> Orders cannot be reversed once they have executed. Please ensure your program has been thoroughly tested before submitting Orders.  If no <code>base_account_id</code> or <code>counter_account_id</code> are specified, your default base currency or counter currency account will be used. You can find your Account IDs by calling the <a href=\"#operation/getBalances\">Balances</a> API.  Permissions required: <code>Perm_W_Orders</code>

        :param pair: The currency pair to trade. (required)
        :type pair: str
        :param type: <code>BID</code> for a bid (buy) limit order<br> <code>ASK</code> for an ask (sell) limit order (required)
        :type type: str
        :param volume: Amount of cryptocurrency to buy or sell as a decimal string in units of the currency. (required)
        :type volume: str
        :param price: Limit price as a decimal string in units of ZAR/BTC. (required)
        :type price: str
        :param time_in_force: <code>GTC</code> Good 'Til Cancelled. The order remains open until it is filled or cancelled by the user.</br> <code>IOC</code> Immediate Or Cancel. The part of the order that cannot be filled immediately will be cancelled. Cannot be post-only.</br> <code>FOK</code> Fill Or Kill. If the order cannot be filled immediately and completely it will be cancelled before any trade. Cannot be post-only.
        :type time_in_force: str
        :param post_only: Post-only Orders will be cancelled if they would otherwise have traded immediately. For example, if there's a bid at ZAR 100,000 and you place a post-only ask at ZAR 100,000, your order will be cancelled instead of trading. If the best bid is ZAR 100,000 and you place a post-only ask at ZAR 101,000, your order won't trade but will go into the order book.
        :type post_only: bool
        :param stop_price: Trigger trade price to activate this order as a decimal string. If this is set then this is treated as a Stop Limit Order and `stop_direction` is expected to be set too.
        :type stop_price: str
        :param stop_direction: Side of the trigger price to activate the order. This should be set if `stop_price` is also set.  `RELATIVE_LAST_TRADE` will automatically infer the direction based on the last trade price and the stop price. If last trade price is less than stop price then stop direction is ABOVE otherwise is BELOW.
        :type stop_direction: str
        :param base_account_id: The base currency Account to use in the trade.
        :type base_account_id: int
        :param counter_account_id: The counter currency Account to use in the trade.
        :type counter_account_id: int
        :param timestamp: Unix timestamp in milliseconds of when the request was created and sent.
        :type timestamp: int
        :param ttl: Specifies the number of milliseconds after timestamp the request is valid for. If `timestamp` is not specified, `ttl` will not be used.
        :type ttl: int
        :param client_order_id: Client order ID. May only contain alphanumeric (0-9, a-z, or A-Z) and special characters (_ ; , . -). Maximum length: 255. It will be available in read endpoints, so you can use it to reconcile Luno with your internal system. Values must be unique across all your successful order creation endpoint calls; trying to create an order with the same `client_order_id` as one of your past orders will result in a HTTP 409 Conflict response.
        :type client_order_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._post_limit_order_serialize(
            pair=pair,
            type=type,
            volume=volume,
            price=price,
            time_in_force=time_in_force,
            post_only=post_only,
            stop_price=stop_price,
            stop_direction=stop_direction,
            base_account_id=base_account_id,
            counter_account_id=counter_account_id,
            timestamp=timestamp,
            ttl=ttl,
            client_order_id=client_order_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "PostLimitOrderResponse",
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _post_limit_order_serialize(
        self,
        pair,
        type,
        volume,
        price,
        time_in_force,
        post_only,
        stop_price,
        stop_direction,
        base_account_id,
        counter_account_id,
        timestamp,
        ttl,
        client_order_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if pair is not None:

            _query_params.append(("pair", pair))

        if type is not None:

            _query_params.append(("type", type))

        if time_in_force is not None:

            _query_params.append(("time_in_force", time_in_force))

        if post_only is not None:

            _query_params.append(("post_only", post_only))

        if volume is not None:

            _query_params.append(("volume", volume))

        if price is not None:

            _query_params.append(("price", price))

        if stop_price is not None:

            _query_params.append(("stop_price", stop_price))

        if stop_direction is not None:

            _query_params.append(("stop_direction", stop_direction))

        if base_account_id is not None:

            _query_params.append(("base_account_id", base_account_id))

        if counter_account_id is not None:

            _query_params.append(("counter_account_id", counter_account_id))

        if timestamp is not None:

            _query_params.append(("timestamp", timestamp))

        if ttl is not None:

            _query_params.append(("ttl", ttl))

        if client_order_id is not None:

            _query_params.append(("client_order_id", client_order_id))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if "Accept" not in _header_params:
            _header_params["Accept"] = self.api_client.select_header_accept(
                ["application/json"]
            )

        # authentication setting
        _auth_settings: List[str] = []

        return self.api_client.param_serialize(
            method="POST",
            resource_path="/api/1/postorder",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    async def post_market_order(
        self,
        pair: Annotated[StrictStr, Field(description="The currency pair to trade.")],
        type: Annotated[
            StrictStr,
            Field(
                description="<code>BUY</code> to buy an asset<br> <code>SELL</code> to sell an asset"
            ),
        ],
        counter_volume: Annotated[
            Optional[StrictStr],
            Field(
                description="For a <code>BUY</code> order: amount of the counter currency to use (e.g. how much EUR to use to buy BTC in the BTC/EUR market)"
            ),
        ] = None,
        base_volume: Annotated[
            Optional[StrictStr],
            Field(
                description="For a <code>SELL</code> order: amount of the base currency to use (e.g. how much BTC to sell for EUR in the BTC/EUR market)"
            ),
        ] = None,
        base_account_id: Annotated[
            Optional[StrictInt],
            Field(description="The base currency account to use in the trade."),
        ] = None,
        counter_account_id: Annotated[
            Optional[StrictInt],
            Field(description="The counter currency account to use in the trade."),
        ] = None,
        timestamp: Annotated[
            Optional[StrictInt],
            Field(
                description="Unix timestamp in milliseconds of when the request was created and sent."
            ),
        ] = None,
        ttl: Annotated[
            Optional[Annotated[int, Field(le=10000, strict=True, ge=1)]],
            Field(
                description="Specifies the number of milliseconds after timestamp the request is valid for. If `timestamp` is not specified, `ttl` will not be used."
            ),
        ] = None,
        client_order_id: Annotated[
            Optional[StrictStr],
            Field(
                description="Client order ID. May only contain alphanumeric (0-9, a-z, or A-Z) and special characters (_ ; , . -). Maximum length: 255. It will be available in read endpoints, so you can use it to reconcile Luno with your internal system. Values must be unique across all your successful order creation endpoint calls; trying to create an order with the same `client_order_id` as one of your past orders will result in a HTTP 409 Conflict response."
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> PostMarketOrderResponse:
        """Post Market Order

        A Market Order executes immediately, and either buys as much of the asset that can be bought for a set amount of fiat currency, or sells a set amount of the asset for as much as possible.  <b>Warning!</b> Orders cannot be reversed once they have executed. Please ensure your program has been thoroughly tested before submitting Orders.  If no <code>base_account_id</code> or <code>counter_account_id</code> are specified, the default base currency or counter currency account will be used. Users can find their account IDs by calling the <a href=\"#operation/getBalances\">Balances</a> request.  Permissions required: <code>Perm_W_Orders</code>

        :param pair: The currency pair to trade. (required)
        :type pair: str
        :param type: <code>BUY</code> to buy an asset<br> <code>SELL</code> to sell an asset (required)
        :type type: str
        :param counter_volume: For a <code>BUY</code> order: amount of the counter currency to use (e.g. how much EUR to use to buy BTC in the BTC/EUR market)
        :type counter_volume: str
        :param base_volume: For a <code>SELL</code> order: amount of the base currency to use (e.g. how much BTC to sell for EUR in the BTC/EUR market)
        :type base_volume: str
        :param base_account_id: The base currency account to use in the trade.
        :type base_account_id: int
        :param counter_account_id: The counter currency account to use in the trade.
        :type counter_account_id: int
        :param timestamp: Unix timestamp in milliseconds of when the request was created and sent.
        :type timestamp: int
        :param ttl: Specifies the number of milliseconds after timestamp the request is valid for. If `timestamp` is not specified, `ttl` will not be used.
        :type ttl: int
        :param client_order_id: Client order ID. May only contain alphanumeric (0-9, a-z, or A-Z) and special characters (_ ; , . -). Maximum length: 255. It will be available in read endpoints, so you can use it to reconcile Luno with your internal system. Values must be unique across all your successful order creation endpoint calls; trying to create an order with the same `client_order_id` as one of your past orders will result in a HTTP 409 Conflict response.
        :type client_order_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._post_market_order_serialize(
            pair=pair,
            type=type,
            counter_volume=counter_volume,
            base_volume=base_volume,
            base_account_id=base_account_id,
            counter_account_id=counter_account_id,
            timestamp=timestamp,
            ttl=ttl,
            client_order_id=client_order_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "PostMarketOrderResponse",
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    async def post_market_order_with_http_info(
        self,
        pair: Annotated[StrictStr, Field(description="The currency pair to trade.")],
        type: Annotated[
            StrictStr,
            Field(
                description="<code>BUY</code> to buy an asset<br> <code>SELL</code> to sell an asset"
            ),
        ],
        counter_volume: Annotated[
            Optional[StrictStr],
            Field(
                description="For a <code>BUY</code> order: amount of the counter currency to use (e.g. how much EUR to use to buy BTC in the BTC/EUR market)"
            ),
        ] = None,
        base_volume: Annotated[
            Optional[StrictStr],
            Field(
                description="For a <code>SELL</code> order: amount of the base currency to use (e.g. how much BTC to sell for EUR in the BTC/EUR market)"
            ),
        ] = None,
        base_account_id: Annotated[
            Optional[StrictInt],
            Field(description="The base currency account to use in the trade."),
        ] = None,
        counter_account_id: Annotated[
            Optional[StrictInt],
            Field(description="The counter currency account to use in the trade."),
        ] = None,
        timestamp: Annotated[
            Optional[StrictInt],
            Field(
                description="Unix timestamp in milliseconds of when the request was created and sent."
            ),
        ] = None,
        ttl: Annotated[
            Optional[Annotated[int, Field(le=10000, strict=True, ge=1)]],
            Field(
                description="Specifies the number of milliseconds after timestamp the request is valid for. If `timestamp` is not specified, `ttl` will not be used."
            ),
        ] = None,
        client_order_id: Annotated[
            Optional[StrictStr],
            Field(
                description="Client order ID. May only contain alphanumeric (0-9, a-z, or A-Z) and special characters (_ ; , . -). Maximum length: 255. It will be available in read endpoints, so you can use it to reconcile Luno with your internal system. Values must be unique across all your successful order creation endpoint calls; trying to create an order with the same `client_order_id` as one of your past orders will result in a HTTP 409 Conflict response."
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[PostMarketOrderResponse]:
        """Post Market Order

        A Market Order executes immediately, and either buys as much of the asset that can be bought for a set amount of fiat currency, or sells a set amount of the asset for as much as possible.  <b>Warning!</b> Orders cannot be reversed once they have executed. Please ensure your program has been thoroughly tested before submitting Orders.  If no <code>base_account_id</code> or <code>counter_account_id</code> are specified, the default base currency or counter currency account will be used. Users can find their account IDs by calling the <a href=\"#operation/getBalances\">Balances</a> request.  Permissions required: <code>Perm_W_Orders</code>

        :param pair: The currency pair to trade. (required)
        :type pair: str
        :param type: <code>BUY</code> to buy an asset<br> <code>SELL</code> to sell an asset (required)
        :type type: str
        :param counter_volume: For a <code>BUY</code> order: amount of the counter currency to use (e.g. how much EUR to use to buy BTC in the BTC/EUR market)
        :type counter_volume: str
        :param base_volume: For a <code>SELL</code> order: amount of the base currency to use (e.g. how much BTC to sell for EUR in the BTC/EUR market)
        :type base_volume: str
        :param base_account_id: The base currency account to use in the trade.
        :type base_account_id: int
        :param counter_account_id: The counter currency account to use in the trade.
        :type counter_account_id: int
        :param timestamp: Unix timestamp in milliseconds of when the request was created and sent.
        :type timestamp: int
        :param ttl: Specifies the number of milliseconds after timestamp the request is valid for. If `timestamp` is not specified, `ttl` will not be used.
        :type ttl: int
        :param client_order_id: Client order ID. May only contain alphanumeric (0-9, a-z, or A-Z) and special characters (_ ; , . -). Maximum length: 255. It will be available in read endpoints, so you can use it to reconcile Luno with your internal system. Values must be unique across all your successful order creation endpoint calls; trying to create an order with the same `client_order_id` as one of your past orders will result in a HTTP 409 Conflict response.
        :type client_order_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._post_market_order_serialize(
            pair=pair,
            type=type,
            counter_volume=counter_volume,
            base_volume=base_volume,
            base_account_id=base_account_id,
            counter_account_id=counter_account_id,
            timestamp=timestamp,
            ttl=ttl,
            client_order_id=client_order_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "PostMarketOrderResponse",
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    async def post_market_order_without_preload_content(
        self,
        pair: Annotated[StrictStr, Field(description="The currency pair to trade.")],
        type: Annotated[
            StrictStr,
            Field(
                description="<code>BUY</code> to buy an asset<br> <code>SELL</code> to sell an asset"
            ),
        ],
        counter_volume: Annotated[
            Optional[StrictStr],
            Field(
                description="For a <code>BUY</code> order: amount of the counter currency to use (e.g. how much EUR to use to buy BTC in the BTC/EUR market)"
            ),
        ] = None,
        base_volume: Annotated[
            Optional[StrictStr],
            Field(
                description="For a <code>SELL</code> order: amount of the base currency to use (e.g. how much BTC to sell for EUR in the BTC/EUR market)"
            ),
        ] = None,
        base_account_id: Annotated[
            Optional[StrictInt],
            Field(description="The base currency account to use in the trade."),
        ] = None,
        counter_account_id: Annotated[
            Optional[StrictInt],
            Field(description="The counter currency account to use in the trade."),
        ] = None,
        timestamp: Annotated[
            Optional[StrictInt],
            Field(
                description="Unix timestamp in milliseconds of when the request was created and sent."
            ),
        ] = None,
        ttl: Annotated[
            Optional[Annotated[int, Field(le=10000, strict=True, ge=1)]],
            Field(
                description="Specifies the number of milliseconds after timestamp the request is valid for. If `timestamp` is not specified, `ttl` will not be used."
            ),
        ] = None,
        client_order_id: Annotated[
            Optional[StrictStr],
            Field(
                description="Client order ID. May only contain alphanumeric (0-9, a-z, or A-Z) and special characters (_ ; , . -). Maximum length: 255. It will be available in read endpoints, so you can use it to reconcile Luno with your internal system. Values must be unique across all your successful order creation endpoint calls; trying to create an order with the same `client_order_id` as one of your past orders will result in a HTTP 409 Conflict response."
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Post Market Order

        A Market Order executes immediately, and either buys as much of the asset that can be bought for a set amount of fiat currency, or sells a set amount of the asset for as much as possible.  <b>Warning!</b> Orders cannot be reversed once they have executed. Please ensure your program has been thoroughly tested before submitting Orders.  If no <code>base_account_id</code> or <code>counter_account_id</code> are specified, the default base currency or counter currency account will be used. Users can find their account IDs by calling the <a href=\"#operation/getBalances\">Balances</a> request.  Permissions required: <code>Perm_W_Orders</code>

        :param pair: The currency pair to trade. (required)
        :type pair: str
        :param type: <code>BUY</code> to buy an asset<br> <code>SELL</code> to sell an asset (required)
        :type type: str
        :param counter_volume: For a <code>BUY</code> order: amount of the counter currency to use (e.g. how much EUR to use to buy BTC in the BTC/EUR market)
        :type counter_volume: str
        :param base_volume: For a <code>SELL</code> order: amount of the base currency to use (e.g. how much BTC to sell for EUR in the BTC/EUR market)
        :type base_volume: str
        :param base_account_id: The base currency account to use in the trade.
        :type base_account_id: int
        :param counter_account_id: The counter currency account to use in the trade.
        :type counter_account_id: int
        :param timestamp: Unix timestamp in milliseconds of when the request was created and sent.
        :type timestamp: int
        :param ttl: Specifies the number of milliseconds after timestamp the request is valid for. If `timestamp` is not specified, `ttl` will not be used.
        :type ttl: int
        :param client_order_id: Client order ID. May only contain alphanumeric (0-9, a-z, or A-Z) and special characters (_ ; , . -). Maximum length: 255. It will be available in read endpoints, so you can use it to reconcile Luno with your internal system. Values must be unique across all your successful order creation endpoint calls; trying to create an order with the same `client_order_id` as one of your past orders will result in a HTTP 409 Conflict response.
        :type client_order_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._post_market_order_serialize(
            pair=pair,
            type=type,
            counter_volume=counter_volume,
            base_volume=base_volume,
            base_account_id=base_account_id,
            counter_account_id=counter_account_id,
            timestamp=timestamp,
            ttl=ttl,
            client_order_id=client_order_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "PostMarketOrderResponse",
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _post_market_order_serialize(
        self,
        pair,
        type,
        counter_volume,
        base_volume,
        base_account_id,
        counter_account_id,
        timestamp,
        ttl,
        client_order_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if pair is not None:

            _query_params.append(("pair", pair))

        if type is not None:

            _query_params.append(("type", type))

        if counter_volume is not None:

            _query_params.append(("counter_volume", counter_volume))

        if base_volume is not None:

            _query_params.append(("base_volume", base_volume))

        if base_account_id is not None:

            _query_params.append(("base_account_id", base_account_id))

        if counter_account_id is not None:

            _query_params.append(("counter_account_id", counter_account_id))

        if timestamp is not None:

            _query_params.append(("timestamp", timestamp))

        if ttl is not None:

            _query_params.append(("ttl", ttl))

        if client_order_id is not None:

            _query_params.append(("client_order_id", client_order_id))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if "Accept" not in _header_params:
            _header_params["Accept"] = self.api_client.select_header_accept(
                ["application/json"]
            )

        # authentication setting
        _auth_settings: List[str] = []

        return self.api_client.param_serialize(
            method="POST",
            resource_path="/api/1/marketorder",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    async def stop_order(
        self,
        order_id: Annotated[
            StrictStr, Field(description="The Order identifier as a string.")
        ],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> StopOrderResponse:
        """Cancel Order

        Request to cancel an Order.  <b>Note!</b>: Once an Order has been completed, it can not be reversed. The return value from this request will indicate if the Stop request was successful or not.  Permissions required: <code>Perm_W_Orders</code>

        :param order_id: The Order identifier as a string. (required)
        :type order_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._stop_order_serialize(
            order_id=order_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "StopOrderResponse",
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    async def stop_order_with_http_info(
        self,
        order_id: Annotated[
            StrictStr, Field(description="The Order identifier as a string.")
        ],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[StopOrderResponse]:
        """Cancel Order

        Request to cancel an Order.  <b>Note!</b>: Once an Order has been completed, it can not be reversed. The return value from this request will indicate if the Stop request was successful or not.  Permissions required: <code>Perm_W_Orders</code>

        :param order_id: The Order identifier as a string. (required)
        :type order_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._stop_order_serialize(
            order_id=order_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "StopOrderResponse",
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    async def stop_order_without_preload_content(
        self,
        order_id: Annotated[
            StrictStr, Field(description="The Order identifier as a string.")
        ],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Cancel Order

        Request to cancel an Order.  <b>Note!</b>: Once an Order has been completed, it can not be reversed. The return value from this request will indicate if the Stop request was successful or not.  Permissions required: <code>Perm_W_Orders</code>

        :param order_id: The Order identifier as a string. (required)
        :type order_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._stop_order_serialize(
            order_id=order_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "StopOrderResponse",
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _stop_order_serialize(
        self,
        order_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if order_id is not None:

            _query_params.append(("order_id", order_id))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if "Accept" not in _header_params:
            _header_params["Accept"] = self.api_client.select_header_accept(
                ["application/json"]
            )

        # authentication setting
        _auth_settings: List[str] = []

        return self.api_client.param_serialize(
            method="POST",
            resource_path="/api/1/stoporder",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )
