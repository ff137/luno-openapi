# coding: utf-8

"""
Luno API

The Luno API provides developers with a wealth of financial information provided through the Luno platform.  Through this secure system developers can:  <ul>    <li>Create accounts for trading in cryptocurrencies</li>    <li>Access current and historic cryptocurrency market data</li>    <li>Submit trade orders and view order status</li>    <li>Buy and sell Bitcoin and Ethereum</li>    <li>Send and receive Bitcoin and Ethereum</li>    <li>Generate Bitcoin and Ethereum wallet addresses</li>  </ul>   The Luno API brings the world of Bitcoin and Ethereum to your doorstep.

The version of the OpenAPI document: 1.2.5
Generated by OpenAPI Generator (https://openapi-generator.tech)

Do not edit the class manually.
"""  # noqa: E501

from typing import Any, Dict, List, Optional, Tuple, Union

from pydantic import Field, StrictBool, StrictFloat, StrictInt, StrictStr, validate_call
from typing_extensions import Annotated

from luno_openapi.api_client import ApiClient, RequestSerialized
from luno_openapi.api_response import ApiResponse
from luno_openapi.models.validate_address_response import ValidateAddressResponse
from luno_openapi.rest import RESTResponseType


class AddressApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client

    @validate_call
    async def validate(
        self,
        address: Annotated[
            StrictStr,
            Field(
                description='Destination address or email address.  <b>Note</b>: <ul> <li>Ethereum addresses must be <a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-55.md" target="_blank" rel="nofollow">checksummed</a>.</li> <li>Ethereum validations of email addresses are not supported.</li> </ul>'
            ),
        ],
        currency: Annotated[
            StrictStr,
            Field(description="Currency is the currency associated with the address."),
        ],
        address_name: Annotated[
            Optional[StrictStr],
            Field(
                description="AddressName is the optional name under which to store the address as in the address book."
            ),
        ] = None,
        has_destination_tag: Annotated[
            Optional[StrictBool],
            Field(
                description="Optional boolean flag indicating that a XRP destination tag is provided (even if zero)."
            ),
        ] = None,
        destination_tag: Annotated[
            Optional[StrictInt],
            Field(
                description="Optional XRP destination tag. Note that HasDestinationTag must be true if this value is provided."
            ),
        ] = None,
        memo: Annotated[
            Optional[StrictStr],
            Field(
                description='Optional memo string used to provide account information for ATOM, etc. where it holds "account" information for a generic address.'
            ),
        ] = None,
        is_self_send: Annotated[
            Optional[StrictBool],
            Field(
                description="IsSelfSend to indicate that the address belongs to the customer. If this field is true then the remaining omitempty fields should not be populated."
            ),
        ] = None,
        is_private_wallet: Annotated[
            Optional[StrictBool],
            Field(
                description="IsPrivateWallet indicates if the address is for private wallet and not held at an exchange."
            ),
        ] = None,
        wallet_name: Annotated[
            Optional[StrictStr],
            Field(description="PrivateWalletName is the name of the private wallet"),
        ] = None,
        beneficiary_name: Annotated[
            Optional[StrictStr],
            Field(
                description="BeneficiaryName is the name of the beneficial owner if is it is a private address"
            ),
        ] = None,
        is_legal_entity: Annotated[
            Optional[StrictBool],
            Field(
                description="IsLegalEntity indicates if the address is for a legal entity and not a private beneficiary. If this field is true then the fields BeneficiaryName, Nationality & DateOfBirth should be empty but the fields InstitutionName and Country should be populated. If this field is false and IsSelfSend is false (or empty) then the field InstitutionName should be empty but the fields BeneficiaryName, Nationality & DateOfBirth and Country should be populated."
            ),
        ] = None,
        institution_name: Annotated[
            Optional[StrictStr],
            Field(
                description="InstitutionName is the name of the beneficial owner if is it is a legal entities address"
            ),
        ] = None,
        country: Annotated[
            Optional[StrictStr],
            Field(
                description="Country is the ISO 3166-1 country code of the beneficial owner of the address"
            ),
        ] = None,
        physical_address: Annotated[
            Optional[StrictStr],
            Field(
                description="PhysicalAddress is the legal physical address of the beneficial owner of the crypto address"
            ),
        ] = None,
        nationality: Annotated[
            Optional[StrictStr],
            Field(
                description="Nationality ISO 3166-1 country code of the nationality of the (non-institutional) beneficial owner of the address"
            ),
        ] = None,
        date_of_birth: Annotated[
            Optional[StrictStr],
            Field(
                description='DateOfBirth is the date of birth of the (non-institutional) beneficial owner of the address in the form "YYYY-MM-DD"'
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ValidateAddressResponse:
        """Validate

        Validate receive addresses, to which a customer wishes to make cryptocurrency sends, are verified under covering regulatory requirements for the customer such as travel rules.  Permissions required: <code>Perm_W_Send</code>

        :param address: Destination address or email address.  <b>Note</b>: <ul> <li>Ethereum addresses must be <a href=\"https://github.com/ethereum/EIPs/blob/master/EIPS/eip-55.md\" target=\"_blank\" rel=\"nofollow\">checksummed</a>.</li> <li>Ethereum validations of email addresses are not supported.</li> </ul> (required)
        :type address: str
        :param currency: Currency is the currency associated with the address. (required)
        :type currency: str
        :param address_name: AddressName is the optional name under which to store the address as in the address book.
        :type address_name: str
        :param has_destination_tag: Optional boolean flag indicating that a XRP destination tag is provided (even if zero).
        :type has_destination_tag: bool
        :param destination_tag: Optional XRP destination tag. Note that HasDestinationTag must be true if this value is provided.
        :type destination_tag: int
        :param memo: Optional memo string used to provide account information for ATOM, etc. where it holds \"account\" information for a generic address.
        :type memo: str
        :param is_self_send: IsSelfSend to indicate that the address belongs to the customer. If this field is true then the remaining omitempty fields should not be populated.
        :type is_self_send: bool
        :param is_private_wallet: IsPrivateWallet indicates if the address is for private wallet and not held at an exchange.
        :type is_private_wallet: bool
        :param wallet_name: PrivateWalletName is the name of the private wallet
        :type wallet_name: str
        :param beneficiary_name: BeneficiaryName is the name of the beneficial owner if is it is a private address
        :type beneficiary_name: str
        :param is_legal_entity: IsLegalEntity indicates if the address is for a legal entity and not a private beneficiary. If this field is true then the fields BeneficiaryName, Nationality & DateOfBirth should be empty but the fields InstitutionName and Country should be populated. If this field is false and IsSelfSend is false (or empty) then the field InstitutionName should be empty but the fields BeneficiaryName, Nationality & DateOfBirth and Country should be populated.
        :type is_legal_entity: bool
        :param institution_name: InstitutionName is the name of the beneficial owner if is it is a legal entities address
        :type institution_name: str
        :param country: Country is the ISO 3166-1 country code of the beneficial owner of the address
        :type country: str
        :param physical_address: PhysicalAddress is the legal physical address of the beneficial owner of the crypto address
        :type physical_address: str
        :param nationality: Nationality ISO 3166-1 country code of the nationality of the (non-institutional) beneficial owner of the address
        :type nationality: str
        :param date_of_birth: DateOfBirth is the date of birth of the (non-institutional) beneficial owner of the address in the form \"YYYY-MM-DD\"
        :type date_of_birth: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._validate_serialize(
            address=address,
            currency=currency,
            address_name=address_name,
            has_destination_tag=has_destination_tag,
            destination_tag=destination_tag,
            memo=memo,
            is_self_send=is_self_send,
            is_private_wallet=is_private_wallet,
            wallet_name=wallet_name,
            beneficiary_name=beneficiary_name,
            is_legal_entity=is_legal_entity,
            institution_name=institution_name,
            country=country,
            physical_address=physical_address,
            nationality=nationality,
            date_of_birth=date_of_birth,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "ValidateAddressResponse",
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    async def validate_with_http_info(
        self,
        address: Annotated[
            StrictStr,
            Field(
                description='Destination address or email address.  <b>Note</b>: <ul> <li>Ethereum addresses must be <a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-55.md" target="_blank" rel="nofollow">checksummed</a>.</li> <li>Ethereum validations of email addresses are not supported.</li> </ul>'
            ),
        ],
        currency: Annotated[
            StrictStr,
            Field(description="Currency is the currency associated with the address."),
        ],
        address_name: Annotated[
            Optional[StrictStr],
            Field(
                description="AddressName is the optional name under which to store the address as in the address book."
            ),
        ] = None,
        has_destination_tag: Annotated[
            Optional[StrictBool],
            Field(
                description="Optional boolean flag indicating that a XRP destination tag is provided (even if zero)."
            ),
        ] = None,
        destination_tag: Annotated[
            Optional[StrictInt],
            Field(
                description="Optional XRP destination tag. Note that HasDestinationTag must be true if this value is provided."
            ),
        ] = None,
        memo: Annotated[
            Optional[StrictStr],
            Field(
                description='Optional memo string used to provide account information for ATOM, etc. where it holds "account" information for a generic address.'
            ),
        ] = None,
        is_self_send: Annotated[
            Optional[StrictBool],
            Field(
                description="IsSelfSend to indicate that the address belongs to the customer. If this field is true then the remaining omitempty fields should not be populated."
            ),
        ] = None,
        is_private_wallet: Annotated[
            Optional[StrictBool],
            Field(
                description="IsPrivateWallet indicates if the address is for private wallet and not held at an exchange."
            ),
        ] = None,
        wallet_name: Annotated[
            Optional[StrictStr],
            Field(description="PrivateWalletName is the name of the private wallet"),
        ] = None,
        beneficiary_name: Annotated[
            Optional[StrictStr],
            Field(
                description="BeneficiaryName is the name of the beneficial owner if is it is a private address"
            ),
        ] = None,
        is_legal_entity: Annotated[
            Optional[StrictBool],
            Field(
                description="IsLegalEntity indicates if the address is for a legal entity and not a private beneficiary. If this field is true then the fields BeneficiaryName, Nationality & DateOfBirth should be empty but the fields InstitutionName and Country should be populated. If this field is false and IsSelfSend is false (or empty) then the field InstitutionName should be empty but the fields BeneficiaryName, Nationality & DateOfBirth and Country should be populated."
            ),
        ] = None,
        institution_name: Annotated[
            Optional[StrictStr],
            Field(
                description="InstitutionName is the name of the beneficial owner if is it is a legal entities address"
            ),
        ] = None,
        country: Annotated[
            Optional[StrictStr],
            Field(
                description="Country is the ISO 3166-1 country code of the beneficial owner of the address"
            ),
        ] = None,
        physical_address: Annotated[
            Optional[StrictStr],
            Field(
                description="PhysicalAddress is the legal physical address of the beneficial owner of the crypto address"
            ),
        ] = None,
        nationality: Annotated[
            Optional[StrictStr],
            Field(
                description="Nationality ISO 3166-1 country code of the nationality of the (non-institutional) beneficial owner of the address"
            ),
        ] = None,
        date_of_birth: Annotated[
            Optional[StrictStr],
            Field(
                description='DateOfBirth is the date of birth of the (non-institutional) beneficial owner of the address in the form "YYYY-MM-DD"'
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ValidateAddressResponse]:
        """Validate

        Validate receive addresses, to which a customer wishes to make cryptocurrency sends, are verified under covering regulatory requirements for the customer such as travel rules.  Permissions required: <code>Perm_W_Send</code>

        :param address: Destination address or email address.  <b>Note</b>: <ul> <li>Ethereum addresses must be <a href=\"https://github.com/ethereum/EIPs/blob/master/EIPS/eip-55.md\" target=\"_blank\" rel=\"nofollow\">checksummed</a>.</li> <li>Ethereum validations of email addresses are not supported.</li> </ul> (required)
        :type address: str
        :param currency: Currency is the currency associated with the address. (required)
        :type currency: str
        :param address_name: AddressName is the optional name under which to store the address as in the address book.
        :type address_name: str
        :param has_destination_tag: Optional boolean flag indicating that a XRP destination tag is provided (even if zero).
        :type has_destination_tag: bool
        :param destination_tag: Optional XRP destination tag. Note that HasDestinationTag must be true if this value is provided.
        :type destination_tag: int
        :param memo: Optional memo string used to provide account information for ATOM, etc. where it holds \"account\" information for a generic address.
        :type memo: str
        :param is_self_send: IsSelfSend to indicate that the address belongs to the customer. If this field is true then the remaining omitempty fields should not be populated.
        :type is_self_send: bool
        :param is_private_wallet: IsPrivateWallet indicates if the address is for private wallet and not held at an exchange.
        :type is_private_wallet: bool
        :param wallet_name: PrivateWalletName is the name of the private wallet
        :type wallet_name: str
        :param beneficiary_name: BeneficiaryName is the name of the beneficial owner if is it is a private address
        :type beneficiary_name: str
        :param is_legal_entity: IsLegalEntity indicates if the address is for a legal entity and not a private beneficiary. If this field is true then the fields BeneficiaryName, Nationality & DateOfBirth should be empty but the fields InstitutionName and Country should be populated. If this field is false and IsSelfSend is false (or empty) then the field InstitutionName should be empty but the fields BeneficiaryName, Nationality & DateOfBirth and Country should be populated.
        :type is_legal_entity: bool
        :param institution_name: InstitutionName is the name of the beneficial owner if is it is a legal entities address
        :type institution_name: str
        :param country: Country is the ISO 3166-1 country code of the beneficial owner of the address
        :type country: str
        :param physical_address: PhysicalAddress is the legal physical address of the beneficial owner of the crypto address
        :type physical_address: str
        :param nationality: Nationality ISO 3166-1 country code of the nationality of the (non-institutional) beneficial owner of the address
        :type nationality: str
        :param date_of_birth: DateOfBirth is the date of birth of the (non-institutional) beneficial owner of the address in the form \"YYYY-MM-DD\"
        :type date_of_birth: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._validate_serialize(
            address=address,
            currency=currency,
            address_name=address_name,
            has_destination_tag=has_destination_tag,
            destination_tag=destination_tag,
            memo=memo,
            is_self_send=is_self_send,
            is_private_wallet=is_private_wallet,
            wallet_name=wallet_name,
            beneficiary_name=beneficiary_name,
            is_legal_entity=is_legal_entity,
            institution_name=institution_name,
            country=country,
            physical_address=physical_address,
            nationality=nationality,
            date_of_birth=date_of_birth,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "ValidateAddressResponse",
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    async def validate_without_preload_content(
        self,
        address: Annotated[
            StrictStr,
            Field(
                description='Destination address or email address.  <b>Note</b>: <ul> <li>Ethereum addresses must be <a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-55.md" target="_blank" rel="nofollow">checksummed</a>.</li> <li>Ethereum validations of email addresses are not supported.</li> </ul>'
            ),
        ],
        currency: Annotated[
            StrictStr,
            Field(description="Currency is the currency associated with the address."),
        ],
        address_name: Annotated[
            Optional[StrictStr],
            Field(
                description="AddressName is the optional name under which to store the address as in the address book."
            ),
        ] = None,
        has_destination_tag: Annotated[
            Optional[StrictBool],
            Field(
                description="Optional boolean flag indicating that a XRP destination tag is provided (even if zero)."
            ),
        ] = None,
        destination_tag: Annotated[
            Optional[StrictInt],
            Field(
                description="Optional XRP destination tag. Note that HasDestinationTag must be true if this value is provided."
            ),
        ] = None,
        memo: Annotated[
            Optional[StrictStr],
            Field(
                description='Optional memo string used to provide account information for ATOM, etc. where it holds "account" information for a generic address.'
            ),
        ] = None,
        is_self_send: Annotated[
            Optional[StrictBool],
            Field(
                description="IsSelfSend to indicate that the address belongs to the customer. If this field is true then the remaining omitempty fields should not be populated."
            ),
        ] = None,
        is_private_wallet: Annotated[
            Optional[StrictBool],
            Field(
                description="IsPrivateWallet indicates if the address is for private wallet and not held at an exchange."
            ),
        ] = None,
        wallet_name: Annotated[
            Optional[StrictStr],
            Field(description="PrivateWalletName is the name of the private wallet"),
        ] = None,
        beneficiary_name: Annotated[
            Optional[StrictStr],
            Field(
                description="BeneficiaryName is the name of the beneficial owner if is it is a private address"
            ),
        ] = None,
        is_legal_entity: Annotated[
            Optional[StrictBool],
            Field(
                description="IsLegalEntity indicates if the address is for a legal entity and not a private beneficiary. If this field is true then the fields BeneficiaryName, Nationality & DateOfBirth should be empty but the fields InstitutionName and Country should be populated. If this field is false and IsSelfSend is false (or empty) then the field InstitutionName should be empty but the fields BeneficiaryName, Nationality & DateOfBirth and Country should be populated."
            ),
        ] = None,
        institution_name: Annotated[
            Optional[StrictStr],
            Field(
                description="InstitutionName is the name of the beneficial owner if is it is a legal entities address"
            ),
        ] = None,
        country: Annotated[
            Optional[StrictStr],
            Field(
                description="Country is the ISO 3166-1 country code of the beneficial owner of the address"
            ),
        ] = None,
        physical_address: Annotated[
            Optional[StrictStr],
            Field(
                description="PhysicalAddress is the legal physical address of the beneficial owner of the crypto address"
            ),
        ] = None,
        nationality: Annotated[
            Optional[StrictStr],
            Field(
                description="Nationality ISO 3166-1 country code of the nationality of the (non-institutional) beneficial owner of the address"
            ),
        ] = None,
        date_of_birth: Annotated[
            Optional[StrictStr],
            Field(
                description='DateOfBirth is the date of birth of the (non-institutional) beneficial owner of the address in the form "YYYY-MM-DD"'
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Validate

        Validate receive addresses, to which a customer wishes to make cryptocurrency sends, are verified under covering regulatory requirements for the customer such as travel rules.  Permissions required: <code>Perm_W_Send</code>

        :param address: Destination address or email address.  <b>Note</b>: <ul> <li>Ethereum addresses must be <a href=\"https://github.com/ethereum/EIPs/blob/master/EIPS/eip-55.md\" target=\"_blank\" rel=\"nofollow\">checksummed</a>.</li> <li>Ethereum validations of email addresses are not supported.</li> </ul> (required)
        :type address: str
        :param currency: Currency is the currency associated with the address. (required)
        :type currency: str
        :param address_name: AddressName is the optional name under which to store the address as in the address book.
        :type address_name: str
        :param has_destination_tag: Optional boolean flag indicating that a XRP destination tag is provided (even if zero).
        :type has_destination_tag: bool
        :param destination_tag: Optional XRP destination tag. Note that HasDestinationTag must be true if this value is provided.
        :type destination_tag: int
        :param memo: Optional memo string used to provide account information for ATOM, etc. where it holds \"account\" information for a generic address.
        :type memo: str
        :param is_self_send: IsSelfSend to indicate that the address belongs to the customer. If this field is true then the remaining omitempty fields should not be populated.
        :type is_self_send: bool
        :param is_private_wallet: IsPrivateWallet indicates if the address is for private wallet and not held at an exchange.
        :type is_private_wallet: bool
        :param wallet_name: PrivateWalletName is the name of the private wallet
        :type wallet_name: str
        :param beneficiary_name: BeneficiaryName is the name of the beneficial owner if is it is a private address
        :type beneficiary_name: str
        :param is_legal_entity: IsLegalEntity indicates if the address is for a legal entity and not a private beneficiary. If this field is true then the fields BeneficiaryName, Nationality & DateOfBirth should be empty but the fields InstitutionName and Country should be populated. If this field is false and IsSelfSend is false (or empty) then the field InstitutionName should be empty but the fields BeneficiaryName, Nationality & DateOfBirth and Country should be populated.
        :type is_legal_entity: bool
        :param institution_name: InstitutionName is the name of the beneficial owner if is it is a legal entities address
        :type institution_name: str
        :param country: Country is the ISO 3166-1 country code of the beneficial owner of the address
        :type country: str
        :param physical_address: PhysicalAddress is the legal physical address of the beneficial owner of the crypto address
        :type physical_address: str
        :param nationality: Nationality ISO 3166-1 country code of the nationality of the (non-institutional) beneficial owner of the address
        :type nationality: str
        :param date_of_birth: DateOfBirth is the date of birth of the (non-institutional) beneficial owner of the address in the form \"YYYY-MM-DD\"
        :type date_of_birth: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._validate_serialize(
            address=address,
            currency=currency,
            address_name=address_name,
            has_destination_tag=has_destination_tag,
            destination_tag=destination_tag,
            memo=memo,
            is_self_send=is_self_send,
            is_private_wallet=is_private_wallet,
            wallet_name=wallet_name,
            beneficiary_name=beneficiary_name,
            is_legal_entity=is_legal_entity,
            institution_name=institution_name,
            country=country,
            physical_address=physical_address,
            nationality=nationality,
            date_of_birth=date_of_birth,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "ValidateAddressResponse",
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _validate_serialize(
        self,
        address,
        currency,
        address_name,
        has_destination_tag,
        destination_tag,
        memo,
        is_self_send,
        is_private_wallet,
        wallet_name,
        beneficiary_name,
        is_legal_entity,
        institution_name,
        country,
        physical_address,
        nationality,
        date_of_birth,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if address is not None:

            _query_params.append(("address", address))

        if currency is not None:

            _query_params.append(("currency", currency))

        if address_name is not None:

            _query_params.append(("address_name", address_name))

        if has_destination_tag is not None:

            _query_params.append(("has_destination_tag", has_destination_tag))

        if destination_tag is not None:

            _query_params.append(("destination_tag", destination_tag))

        if memo is not None:

            _query_params.append(("memo", memo))

        if is_self_send is not None:

            _query_params.append(("is_self_send", is_self_send))

        if is_private_wallet is not None:

            _query_params.append(("is_private_wallet", is_private_wallet))

        if wallet_name is not None:

            _query_params.append(("wallet_name", wallet_name))

        if beneficiary_name is not None:

            _query_params.append(("beneficiary_name", beneficiary_name))

        if is_legal_entity is not None:

            _query_params.append(("is_legal_entity", is_legal_entity))

        if institution_name is not None:

            _query_params.append(("institution_name", institution_name))

        if country is not None:

            _query_params.append(("country", country))

        if physical_address is not None:

            _query_params.append(("physical_address", physical_address))

        if nationality is not None:

            _query_params.append(("nationality", nationality))

        if date_of_birth is not None:

            _query_params.append(("date_of_birth", date_of_birth))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if "Accept" not in _header_params:
            _header_params["Accept"] = self.api_client.select_header_accept(
                ["application/json"]
            )

        # authentication setting
        _auth_settings: List[str] = []

        return self.api_client.param_serialize(
            method="POST",
            resource_path="/api/1/address/validate",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )
